package com.huypq.web.admin.security;

import com.huypq.web.admin.domain.AppUserDetail;
import com.huypq.web.admin.domain.User;
import com.huypq.web.admin.repository.UserRepository;
import com.huypq.web.admin.rest.error.Resources;
import com.huypq.web.admin.service.UserService;
import com.huypq.web.admin.service.exception.ErrorMessage;
import com.huypq.web.admin.service.exception.OauthException;
import lombok.extern.slf4j.Slf4j;
import org.hibernate.validator.internal.constraintvalidators.hv.EmailValidator;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.AuthenticationException;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.security.oauth2.provider.authentication.OAuth2AuthenticationManager;
import org.springframework.util.StringUtils;
import ua_parser.Client;
import ua_parser.Parser;

import java.sql.Timestamp;
import java.time.Instant;
import java.time.temporal.ChronoUnit;
import java.util.*;
import java.util.stream.Collectors;

@Slf4j
public class AppAuthenticationManager extends OAuth2AuthenticationManager {
    private static final Logger logger = LoggerFactory.getLogger(AppAuthenticationManager.class);

    private final UserRepository userRepository;

    private final PasswordEncoder passwordEncoder;

    private final UserService userService;

    public AppAuthenticationManager(UserRepository userRepository, PasswordEncoder passwordEncoder, UserService userService) {
        super();
        this.userRepository = userRepository;
        this.passwordEncoder = passwordEncoder;
        this.userService = userService;
    }

    @Override
    public Authentication authenticate(Authentication authentication) throws AuthenticationException {
        logger.info("authentication " + authentication);
        if (authentication == null) {
            throw new OauthException(ErrorMessage.INVALID_USERNAME_OR_PASSWORD, "", "", 0L);
        }
        // if grant_type = refresh_token -> reload permission only
        Map<String, String> detailMap = (Map<String, String>) authentication.getDetails();
        String grantType = detailMap.get("grant_type");
        if ("refresh_token".equals(grantType)) {
            return handlerRefreshPermission(authentication);
        }

        // handler password grant
        Timestamp currentTime = new Timestamp(new Date().getTime());
        Calendar cal = Calendar.getInstance();
//        Integer domainId = 1;
        String username = authentication.getPrincipal().toString();
        if (username != null) {
            username = username.trim();
        }
        String password = authentication.getCredentials().toString();
        if (password != null) {
            password = password.trim();
        }
//        domainId = getDomainIdFromRequest(domainId, detailMap);

        User user = loadUserByUsernameOrEmail(username);
        // Step 4: check account lock status
        checkUserLockAndActiveStatus(user);
        // Step 5: check user password
        checkUserPassword(password, user);
        // 5.2 : if correct password and user is inactive
        if (!user.isActivated()) {
            throw new OauthException(ErrorMessage.ACCOUNT_IS_DISABLED, "", "", 0L);
        }
        // reset login fail count
        user.setLoginFailCount(0l);
        userRepository.save(user);

        // if user's password is generated by system or changed/reset more than 90 days ago then require change password
        cal.setTimeInMillis(currentTime.getTime());
        cal.add(Calendar.DATE, -90);
        // get limit change password date
        AppUserDetail appUserDetail = new AppUserDetail(user);
        // load permission for role user staff
//        if (!appUserDetail.getIsRootOrAdmin()) {
//            handlerLoadPermissionForRoleUser(domainId, user, appUserDetail);
//        }
        // Handler success auth -> create token
        return new UsernamePasswordAuthenticationToken(appUserDetail, null, appUserDetail.getAuthorities());
    }

    private Authentication handlerRefreshPermission(Authentication authentication) {
        String username = authentication.getPrincipal().toString();
        Map<String, String> requestParams = (Map<String, String>) authentication.getDetails();
//        Integer domainId = getDomainIdFromRequest(1, requestParams);
        User user = loadUserByUsernameOrEmail(username);
        // handler inactive status only
        if (!user.isActivated()) {
            throw new OauthException(ErrorMessage.ACCOUNT_IS_DISABLED, "", "", 0L);
        }
        AppUserDetail appUserDetail = new AppUserDetail(user);
        // load permission for role user staff
//        if (!appUserDetail.getIsRootOrAdmin()) {
//            handlerLoadPermissionForRoleUser(domainId, user, appUserDetail);
//        }
        // Handler success auth -> create token
        return new UsernamePasswordAuthenticationToken(appUserDetail, null, appUserDetail.getAuthorities());
    }

//    private void checkUserDomain(Integer domainId, User user) {
//        if (AuthoritiesConstants.USER.equals(user.getAuthority().getName())) {
//            UserDomain userDomain = userDomainRepository.findByUserIdAndDomainId(user.getId(), domainId);
//            if (userDomain == null) {
//                throw new OauthException(ErrorMessage.INVALID_DOMAIN_PERMISSION, "", "", 0L);
//            }
//        }
//    }

//    private void saveUserLoginHistory(Map<String, String> detailMap, User user) {
//        UserLoginHistory userLoginHistory = new UserLoginHistory();
//        userLoginHistory.setUser(user);
//        userLoginHistory.setIpAddress(detailMap.get(SSOConstants.CLIENT_IP_KEY));
//        String clientDevice = detailMap.get(SSOConstants.CLIENT_DEVICE_KEY);
//        if (StringUtils.hasText(clientDevice)) {
//            StringBuilder clientDeviceSb = this.buildClientDeviceInfo(clientDevice);
//            if (StringUtils.hasText(clientDeviceSb)) {
//                clientDevice = clientDeviceSb.toString();
//            } else if (clientDevice.length() > 255) {
//                clientDevice = clientDevice.substring(0, 255);
//            }
//        }
//        userLoginHistory.setDevice(clientDevice);
//        userLoginHistory.setLoginDateTime(Timestamp.from(Instant.now()));
//        userLoginHistoryRepository.save(userLoginHistory);
//        log.info("Save login success history: {}", userLoginHistory);
//    }

//    private StringBuilder buildClientDeviceInfo(String clientDevice) {
//        Parser uagParser = new Parser();
//        Client uagClientMetadata = uagParser.parse(clientDevice);
//        StringBuilder fullOutput = new StringBuilder();
//        if (uagClientMetadata == null || "Other".equals(uagClientMetadata.userAgent.family)) {
//            return fullOutput;
//        }
//        if (StringUtils.hasText(uagClientMetadata.os.family)) {
//            fullOutput.append(uagClientMetadata.os.family);
//            if (StringUtils.hasText(uagClientMetadata.os.major)) {
//                fullOutput.append(" ");
//                fullOutput.append(uagClientMetadata.os.major);
//            }
//        }
//        if (StringUtils.hasText(uagClientMetadata.userAgent.family)) {
//            fullOutput.append(" - ");
//            fullOutput.append(uagClientMetadata.userAgent.family);
//            if (StringUtils.hasText(uagClientMetadata.userAgent.major)) {
//                fullOutput.append(" ");
//                fullOutput.append(uagClientMetadata.userAgent.major);
//            }
//        }
//        return fullOutput;
//    }

//    private void handlerLoadPermissionForRoleUser(Integer domainId, User user, appUserDetail appUserDetail) {
//        // get all screenId and linkedScreenId with permission type by userId and domainId
//        List<UserDomainPermissionTypeDTO> allUserPermissionTypeByDomain = this.userRepository.getAllUserPermissionTypeByDomain(user.getId(), domainId);
//        // collect all screenId and permission type
//        Map<Integer, Integer> screenPermissionTypeMap = new HashMap<>();
//        allUserPermissionTypeByDomain.forEach(elm -> {
//            if (screenPermissionTypeMap.containsKey(elm.getScreenId())) {
//                if (screenPermissionTypeMap.get(elm.getScreenId()).compareTo(elm.getPermissionType()) < 0) {
//                    screenPermissionTypeMap.put(elm.getScreenId(), elm.getPermissionType());
//                }
//            } else {
//                screenPermissionTypeMap.put(elm.getScreenId(), elm.getPermissionType());
//            }
//            if (elm.getLinkedScreenId() != null &&
//                    !screenPermissionTypeMap.containsKey(elm.getLinkedScreenId()) &&
//                    screenPermissionTypeMap.get(elm.getScreenId()).equals(SSOConstants.PERMISSION_TYPE_WRITE)) {
//                screenPermissionTypeMap.put(elm.getLinkedScreenId(), SSOConstants.PERMISSION_TYPE_READ);
//            }
//        });
//        appUserDetail.setGroupPermissionDetails(screenPermissionTypeMap);
//        // Transform to GrantAuthority simple String for writing in jwt access token
//        Set<String> allPermission = screenPermissionTypeMap
//                .entrySet()
//                .stream()
//                .map(entry -> String.join("_", String.valueOf(entry.getKey()), String.valueOf(entry.getValue())))
//                .collect(Collectors.toSet());
//        appUserDetail.setPermissions(allPermission);
//
//        // check permission for website in portal
//        // check for slice
//        Set<String> allowWebsitePortal = new LinkedHashSet<>();
//        allowWebsitePortal.add(OcsWebsiteEnum.DASHBOARD.name());
//        Set<Integer> allowScreenIds = screenPermissionTypeMap.keySet();
//        // check for SLICE
//        if (allowScreenIds.stream().anyMatch(SSOConstants.ALL_SLICE_SCREEN_IDS::contains)) {
//            allowWebsitePortal.add(OcsWebsiteEnum.SLICE.name());
//        }
//        // check for PRODUCT
//        if (allowScreenIds.stream().anyMatch(SSOConstants.ALL_PRODUCT_SCREEN_IDS::contains)) {
//            allowWebsitePortal.add(OcsWebsiteEnum.PRODUCT.name());
//        }
//        // check for WEBTOOL
//        if (allowScreenIds.stream().anyMatch(SSOConstants.ALL_WEBTOOL_SCREEN_IDS::contains)) {
//            allowWebsitePortal.add(OcsWebsiteEnum.WEBTOOL.name());
//        }
//        appUserDetail.setWebsitePermissions(allowWebsitePortal);
//    }

    private void checkUserPassword(String password, User user) {
        if (!passwordEncoder.matches(password, user.getPassword())) {
            Long failCount = user.getLoginFailCount() + 1;
            user.setLoginFailCount(failCount);
            // set lock time account when user login fail 10 times or more
            // Lock login for 5 minutes
            if (failCount >= 10) {
                user.setAccountLockUntilDateTime(Timestamp.from(Instant.now().plus(5, ChronoUnit.MINUTES)));
            }
            userRepository.save(user);
            throw new OauthException(ErrorMessage.INVALID_USERNAME_OR_PASSWORD, "", "", user.getLoginFailCount());
        }
    }

    private void checkUserLockAndActiveStatus(User user) {
        if (user.getAccountLockUntilDateTime() != null && user.getAccountLockUntilDateTime().after(new Timestamp(new Date().getTime()))) {
            throw new OauthException(ErrorMessage.ACCOUNT_IS_LOCKED, "", "", user.getLoginFailCount());
        }
        if (!user.isActivated()) {
            throw new OauthException(ErrorMessage.ACCOUNT_IS_DISABLED, "", "", 0L);
        }
    }

//    private Integer getDomainIdFromRequest(Integer domainId, Map<String, String> detailMap) {
//        if (detailMap.get("domainId") != null) {
//            try {
//                domainId = Integer.parseInt(detailMap.get("domainId"));
//            } catch (NumberFormatException e) {
//                throw new OauthException(ErrorMessage.INVALID_DOMAIN, "", "", 0L);
//                // N/A fallback for old version
//            }
//        }
//        return domainId;
//    }

    private User loadUserByUsernameOrEmail(String username) {
        // if user login with email
        if (new EmailValidator().isValid(username, null)) {
            Optional<User> userOptional = userRepository.findOneWithAuthorityByEmailIgnoreCase(username);
            if (userOptional.isEmpty()) {
                throw new OauthException(ErrorMessage.INVALID_USERNAME_OR_PASSWORD, Resources.USER, "email", 0L);
            }
            return userOptional.get();
        }
        // if user login with username
        return userRepository.findOneByUsernameIgnoreCase(username).orElseThrow(() -> new OauthException(ErrorMessage.INVALID_USERNAME_OR_PASSWORD, Resources.USER, "email", 0L));
    }

}
